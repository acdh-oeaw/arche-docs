---
title: "ARCHE Search API for programmers"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
---

# Conventions

* RDF property URIs are quite often shortened using following prefixes:
  ```
  acdh https://vocabs.acdh.oeaw.ac.at/schema#
  acdhi https://id.acdh.oeaw.ac.at
  ```
* The `{repoCfg}$.X.Y` syntax means an `$.X.Y` [JSON path](https://github.com/json-path/JsonPath) over the repository configuration returned by its [describe](https://app.swaggerhub.com/apis/zozlak/arche/3.5#/default/get_describe) REST API endpoint,
  e.g. `{repoCfg}$.schema.label` on https://arche.acdh.oeaw.ac.at/api resolves to `https://vocabs.acdh.oeaw.ac.at/schema#hasTitle`.
* Search URLs examples always come in pairs:
  * A human-readable version with non-URL-encoded parameter values and every parameter written in a new line.
  * A copy-paste friendly (but human-unreadable) version allowing you to test it easily in a browser/curl/postman/whatsoever.
* Most search URL examples use `readMode=resource` and `format=text/turtle` to provide the most human-readable output
  allowing to focus on the topic being discussed.
  For a real-world usage you're likely use a different `readMode` and/or output format.

# General advices

* If you haven't read the [using RDF in webapps](https://acdh-oeaw.github.io/arche-docs/aux/rdf_basics.html) guide, please do it first.
  This should allow us to avoid many misconceptions coming from the fact that the ARCHE REST api provides metadata in RDF.
* Before making a complex search, think for a moment if what you want can't be achieved with a [readMode](metadata_api_for_programmers.html#readmode-in-details).
  A request using the `readMode` and a simple search condition will be simpler, easier to understand and is likely to run faster.
* If your search is likely to match hundreds of resources and you don't use paging, you'll be better off using **resourceProperties** and **relativesProperties** parameters - see [here](https://acdh-oeaw.github.io/arche-docs/aux/metadata_api_for_programmers.html#metadata-retrieval-performance).

# Technical RDF properties provided by the search

The search endpoint annotates search results with some RDF properties:

| subject            | property                                     | object value type     | object value description                                |
|--------------------|----------------------------------------------|-----------------------|---------------------------------------------------------|
| `{restAPIbaseURL}` | `{repoCfg}$.schema.searchCount`              | `xsd:integer`         | total number of resources matched by the search         |
| `resourceURI`      | `{repoCfg}$.schema.searchMatch`              | `"true"^^xsd:boolean` | marks resources matching the search (to distinguish them from the ones fetched because of the [readMode](metadata_api_for_programmers.html#readmode-in-details)) |
| `resourceURI`      | `{repoCfg}$.schema.searchOrder`              | `xsd:positiveInteger` | order of the resource within the search results according to the `orderBy[]` request parameter(s) - see the [Ordering results](#ordering-results) chapter below - only when the `orderBy[]` request parameter(s) was provided |
| `resourceURI`      | `{repoCfg}$.schema.searchOrderValue` + `{N}` | mixed                 | actual value of the RDF property indicated by the `orderBy[{N}]` request parameter used for ordering the results - see the [Ordering results](#ordering-results) chapter below - only when the `orderBy[]` request parameter(s) was provided |
| `resourceURI`      | `{repoCfg}$.schema.searchFts`                | `xsd:string`          | highlighted full text search matches - only when a full text search was performed |

# Using array parameters

Many search API parameters are arrays and some of them accept nested arrays of values.

The good thing is, if you're using any library to make the API request, the library should be able to properly serialize everything for you, e.g.
_find all resources with `someProp` having either `somePropValue1` or `somePropValue2` value and `otherProp` having `otherPropValue`_:

```js
// jQuery example
jQuery.ajax({
  url: 'https://arche.acdh.oeaw.ac.at/api/search',
  data: {
    'property': ['someProp',                           'otherProp'],
    'value':    [['somePropValue1', 'somePropValue2'], 'otherPropValue'],
    'readMode': 'resource',
    'format': 'text/turtle'
  },
  success: function(d) {console.log(d)}
})
```
```python
# Python example
import requests 
resp = requests.get(
  'https://arche.acdh.oeaw.ac.at/api/search',
  params={
    'property': ['someProp',                           'otherProp'],
    'value':    [['somePropValue1', 'somePropValue2'], 'otherPropValue'],
    'readMode': 'resource',
    'format': 'text/turtle'
  }
)
print(resp.text)
```

Anyway, if for some reason you need/want to construct the request URL by hand, that's how it works.

There are a two conventions of passing array parameters:

* With implicit enumeration, e.g (`URL representation => internal representation`):
  ```
  property[]=someProp&property[]=otherProp => {0: someProp, 1: otherProp}
  ```
  * This syntax makes it impossible to pass a given element value as an array
   `property[][]=someProp&prop[][]=orOtherProp` **won't work**.
* With explicit enumeration - they key is provided in the request parameter name, e.g (`URL representation => internal representation`):
  ```
  property[0]=someProp&property[1]=otherProp => {0: someProp, 1: otherProp}
  property[9]=someProp&property[4]=otherProp => {9: someProp, 4: otherProp}
  property[foo]=someProp&property[bar]=otherProp => {foo: someProp, bar: otherProp}
  ```
  * This syntax allows to pass a value being an array, e.g.
    ```
    property[0][]=someProp&property[0][]=orOther&property[1]=oneMore => {0: [someProp, orOther], 1: oneMore}
    ```
  * If a key is repeated, the last value overwrites the previous ones, e.g.
    ```
    property[0]=someProp&property[0]=otherProp => {0: otherProp}
    ```
* It is also technically possible to mix both conventions, e.g. (`URL representation => internal representation`):
  ```
  property[]=someProp&property[1]=otherProp => [0 => someProp, 1 => otherProp]
  property[]=someProp&property[0]=otherProp => [0 => otherProp]
  property[foo]=someProp&property[]=otherProp => [foo => someProp, 0 => otherProp]
  ```
  but it doesn't mean you should use it just because you can :-)

Now, when constructing the actual search conditions ARCHE just tries to match `property[]`, `operator[]`, `value[]` and `lang[]`
parameters with the same key. It doesn't matter if a key is numeric or non-numeric and if it was generated implicitly or explicitly.
A union of all keys existing for `property[]`, `value[]` and `lang[]` is taken
(`operator[]` isn't included because it's impossible to construct a condition based only on the operator), e.g.:

```
property[foo]=fooProp
&operator[foo]=@@
&value[foo]=fooValue
&value[]=value
&lang[0]=en
&property[5]=otherProp
```

will result with an internal representation of:

```
property: {          5: otherProp, foo: fooProp }
operator: {                        foo: @@      }
value:    {0: value,               foo: fooValue}
lang:     {0: en                                }
```

and the search condition _find all resources having at the same time: a triple with value `value@en` and any triple with the `otherProp` and a triple with property `fooProp` and value matching a full text search for `fooValue`_.

# Ordering results

## Simple case

Just use the `oderbBy[]` request parameter coupled with the `orderByLang` if needed,
e.g. let's search for all resources bigger than 1.3 GB ordering results by their `acdh:hasTitle`
(in any language provided):

```
https://arche.acdh.oeaw.ac.at/api/search
  ?property[0]=https://vocabs.acdh.oeaw.ac.at/schema#hasRawBinarySize
  &operator[0]=>
  &value[0]=13000000000
  &orderBy[0]=https://vocabs.acdh.oeaw.ac.at/schema#hasTitle
  &readMode=resource
  &format=text/turtle
  
https://arche.acdh.oeaw.ac.at/api/search?property%5B0%5D=https%3A%2F%2Fvocabs.acdh.oeaw.ac.at%2Fschema%23hasRawBinarySize&operator%5B0%5D=%3E&value%5B0%5D=10000000000&orderBy%5B0%5D=https%3A%2F%2Fvocabs.acdh.oeaw.ac.at%2Fschema%23hasTitle&readMode=resource&format=text%2Fturtle
```

And take a look at the returned data skipping uninteresting properties:

```
<https://arche.acdh.oeaw.ac.at/api/> <search://count> "7"^^<http://www.w3.org/2001/XMLSchema#integer> .

<https://arche.acdh.oeaw.ac.at/api/23174>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize  "17222812879"^^<http://www.w3.org/2001/XMLSchema#long>;
    <search://order>       "7"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1> "KHM-ANSA-IV3456_raw3d.zip";
    acdh:hasTitle          "KHM-ANSA-IV3456_raw3d.zip"@en.
<https://arche.acdh.oeaw.ac.at/api/37779>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize  "13039382156"^^<http://www.w3.org/2001/XMLSchema#long>;
    <search://order>       "6"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1> "KHM-ANSA-IV431_raw3d.zip";
    acdh:hasTitle          "KHM-ANSA-IV431_raw3d.zip"@en.
<https://arche.acdh.oeaw.ac.at/api/46542>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize   "15927776264"^^<http://www.w3.org/2001/XMLSchema#nonNegativeInteger>;
    <search://order>        "5"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1>  "sfm_raw_04-p1.zip";
    acdh:hasTitle           "sfm_raw_04-p1.zip"@de.
(...)
```

Discussion:

* The mapping of technical annotation properties to actual URIs follows the schema reported by the
  https://arche.acdh.oeaw.ac.at/api/describe, so that
  * `{repoCfg}$.schema.searchCount` is `<search://match>`,
  * `{repoCfg}$.schema.searchOrder` is `<search://order>`,
  * `{repoCfg}$.schema.searchOrderValue` + `{N}` is `<search://orderValue1>`, `<search://orderValue2>`, etc.
* All resources matched by the search are marked with `<search://match> true`.
  The one which isn't - `<https://arche.acdh.oeaw.ac.at/api/>` - is a technical resources
  used to indicate global search result properties like the number of resources matched by the search (here 7).
* The requested order can be read from `<search://order>` property values.
  The ascending order seems to be kept.
  * If you want an descending order, just prepend the property URI with a `^` in the `orderBy[]` parameter,
    e.g. `orderBy[0]=^https://vocabs.acdh.oeaw.ac.at/schema#hasTitle`.
  * If you want to order by more then one property, provide many `orderBy[]` request parameters,
    e.g. `orderBy[0]=firstOrderByThisProperty&orderBy[1]=thenOrderByThatProperty`.
    * Multiple `orderBy[]` parameter values are first sorted by their (implicit or explicit) key, e.g.
      `orderBy[foo]=someProp&orderBy[bar]=otherProp` will order results first by the `otherProp` values
      and only then by the `someProp` values (because the `bar` key is smaller than the `foo` key).
* Values actually used for ordering are provided in the `<search://orderValue1>` property.
  * As requested they are just equal to the `achd:hasTitle` property value of a given resource, just they
    lack the language tag.
    Here it's obvious but things can quickly get complicated if a resource has more than one title
    - see the next chapters.
  * There will be as many `<search://orderValueN>` properties in the output, as many `orderBy[]` parameters
    were provided in the request, e.g. if you requested `orderBy[0]=someProp&orderBy[1]=otherProp`,
    the output will contain both `<search://orderValue1>` (storing `someProp` values actually used for sorting)
    and ``<search://orderValue2>` (storing `otherProp` values actually used for sorting).
    * The N-th `<search://orderValueN>` property stores values of the n-th-order sorting property, so e.g.
      for `orderBy[foo]=someProp&orderBy[bar]=otherProp`, the `<search://orderValue1>` provides values of
      the `otherProp` and `<search://orderValue2>` provides values of the `someProp`.
      
## Collation

Different languages have different opinions on the characters order.
It's possible that the rule used by the ARCHE instance isn't in line with what you expect.
Fortunately there's can be easily checked and controlled:

* Inspect the `$.collation.default` value of the data returned by the `/describe` REST API endpoint
  to know what's the collation used by default by a given ARCHE instance.
  (e.g. https://arche.acdh.oeaw.ac.at/api/describe reports `en_US.UTF-8`).
* Use the `orderByCollation` request parameter to enforce ordering according to a given collation.
  * Inspect the `$.collation.available` to get the list of all collations available on a given
    ARCHE instance.

## Multiple values

A resource may have multiple values of a property used for results ordering.
A typical case are labels in multiple languages but you shouldn't assume it's the only possible case.
Consult metadata schema to check if a given property may multiple values and if they have a language tag.

In case of multiple property values ARCHE implements two rules:

* It the `orderByLang` request property is provided, all values with a non-matching values are excluded.
  * It a value has no language tag (technically speaking if its type is other than `rdfs:langString`),
    it's also included.
  * If there's no value left for a given resource, it's ordered as the last.
  * If a property has multiple values with the desired language tag, all of them are taken and the
    rule from the next point is applied.
  * It's a global setting. You can't assign different values for differnt `orderBy[]` parameter values.
* The lowest value among the available ones is used for the sorting.
  * This is a fully arbitrary ARCHE's design decision.
    We need to pick up a single value, we're using the lowest one.

TODO - add examples.

## Lack of value and non-literal values

If a given resource lacks a triple of the `orderBy[]` property **with a literal value**, then it's 
put at the end of the search results.

By the way it means **ARCHE doesn't allow to order by an object property values.**
This is because an ARCHE resource may have any number of (equally important) identifiers making
it impossible to tell, which one should be used (at least without introducing additional complexity
to the API).

# Paging 

Search results may be paged. This is controlled by the `offset` and `limit` parameters.

* You almost for sure want to combine paging with explicit ordering (see the previous chapter).
  * Still it's technically safe to use paging without providing `orderBy[]`.
    In such a case ARCHE resources are ordered by their internal identifiers
    which doesn't provide any intuitive order but is stable.
* You can always check the total number of resources matching the search by inspecting the
  `<restAPIbaseURL> <{repoCfg}$.schema.searchCount> "count" .` response triple, e.g.
  ```
  <https://arche.acdh.oeaw.ac.at/api/> <search://count> "7"^^<http://www.w3.org/2001/XMLSchema#integer> .
  ```
* The requested values of the `offset` and `limit` aren't included in the output.
  ARCHE hopes you can remember them :-)

# Full text search

TODO