---
title: "ARCHE Search API for programmers"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
---

# Conventions

* RDF property URIs are quite often shortened using following prefixes:
  ```
  acdh https://vocabs.acdh.oeaw.ac.at/schema#
  acdhi https://id.acdh.oeaw.ac.at
  ```
* The `{repoCfg}$.X.Y` syntax means an `$.X.Y` [JSON path](https://github.com/json-path/JsonPath) over the repository configuration returned by its [describe](https://app.swaggerhub.com/apis/zozlak/arche/3.5#/default/get_describe) REST API endpoint,
  e.g. `{repoCfg}$.schema.label` on https://arche.acdh.oeaw.ac.at/api resolves to `https://vocabs.acdh.oeaw.ac.at/schema#hasTitle`.
* Full Search URLs examples always come in pairs:
  * A human-readable version with non-URL-encoded parameter values and every parameter written in a new line.
  * A copy-paste friendly (but human-unreadable) version allowing you to test it easily in a browser/curl/postman/whatsoever.
* Short examples of particular API parameters are always provided in non-URL-encoded form
  (read "just copy-pasting them into the browser/curl may not work").
* Most search URL examples use `readMode=resource` and `format=text/turtle` to provide the most human-readable output
  allowing to focus on the topic being discussed.
  For a real-world usage you're likely use a different `readMode` and/or output format.

# General advices

* If you haven't read the [using RDF in webapps](https://acdh-oeaw.github.io/arche-docs/aux/rdf_basics.html) guide, please do it first.
  This should allow us to avoid many misconceptions coming from the fact that the ARCHE REST api provides metadata in RDF.
* Before making a complex search, think for a moment if what you want can't be achieved with a [readMode](metadata_api_for_programmers.html#readmode-in-details).
  A request using the `readMode` and a simple search condition will be simpler, easier to understand and is likely to run faster.
* If your search is likely to match hundreds of resources and you don't use paging, you'll be better off using **resourceProperties** and **relativesProperties** parameters - see [here](https://acdh-oeaw.github.io/arche-docs/aux/metadata_api_for_programmers.html#metadata-retrieval-performance).

# Technical RDF properties provided by the search

The search endpoint annotates search results with some RDF properties:

| subject            | property                                     | object value type     | object value description                                |
|--------------------|----------------------------------------------|-----------------------|---------------------------------------------------------|
| `{restAPIbaseURL}` | `{repoCfg}$.schema.searchCount`              | `xsd:integer`         | total number of resources matched by the search         |
| `resourceURI`      | `{repoCfg}$.schema.searchMatch`              | `"true"^^xsd:boolean` | marks resources matching the search (to distinguish them from the ones fetched because of the [readMode](metadata_api_for_programmers.html#readmode-in-details)) |
| `resourceURI`      | `{repoCfg}$.schema.searchOrder`              | `xsd:positiveInteger` | order of the resource within the search results according to the `orderBy[]` request parameter(s) - see the [Ordering results](#ordering-results) chapter below - only when the `orderBy[]` request parameter(s) was provided |
| `resourceURI`      | `{repoCfg}$.schema.searchOrderValue` + `{N}` | mixed                 | actual value of the RDF property indicated by the `orderBy[{N}]` request parameter used for ordering the results - see the [Ordering results](#ordering-results) chapter below - only when the `orderBy[]` request parameter(s) was provided |
| `resourceURI`      | `{repoCfg}$.schema.searchFts`                | `xsd:string`          | highlighted full text search matches - only when a full text search was performed |

# Using array parameters in request query

Many search API parameters are arrays and some of them (`property[]` and `value[]`) accept nested arrays of values.

ARCHE APIP supports two conventions of passing array parameters:

* With implicit enumeration, e.g (`URL representation => internal representation`):
  ```
  property[]=someProp&property[]=otherProp => {0: someProp, 1: otherProp}
  ```
  * This syntax makes it impossible to pass a given element value as an array as
   ```
   property[][]=someProp&prop[][]=orOtherProp => {0: {0: someProp}, 1: {0: orOtherProp}}`
   ```
   while the internal representation we want to end up with is:
   ```
   {0: {0: someProp, 1: orOtherProp}}
   ```
* With explicit enumeration - they key is provided in the request parameter name, e.g (`URL representation => internal representation`):
  ```
  property[0]=someProp&property[1]=otherProp => {0: someProp, 1: otherProp}
  property[9]=someProp&property[4]=otherProp => {9: someProp, 4: otherProp}
  property[foo]=someProp&property[bar]=otherProp => {foo: someProp, bar: otherProp}
  ```
  * This syntax allows to pass a value being an array, e.g.
    ```
    property[0][]=someProp&property[0][]=orOther&property[1]=oneMore => {0: [someProp, orOther], 1: oneMore}
    ```
  * If a key is repeated, the last value overwrites the previous ones, e.g.
    ```
    property[0]=someProp&property[0]=otherProp => {0: otherProp}
    ```
* It is also technically possible to mix both conventions, e.g. (`URL representation => internal representation`):
  ```
  property[]=someProp&property[1]=otherProp   => {0 => someProp, 1 => otherProp}
  property[]=someProp&property[0]=otherProp   => {0 => otherProp}
  property[foo]=someProp&property[]=otherProp => {foo => someProp, 0 => otherProp}
  ```
  but it doesn't mean you should use it just because you can :-)
  (it's easy to make stupid mistakes when you mix conventions)

Now, when constructing the actual search conditions ARCHE just tries to match `property[]`, `operator[]`, `value[]` and `lang[]`
parameters with the same key. It doesn't matter if a key is numeric or non-numeric and if it was generated implicitly or explicitly.
A union of all keys existing for `property[]`, `value[]` and `lang[]` is taken
(`operator[]` isn't included because it's impossible to construct a condition based only on the operator), e.g.:

```
property[foo]=fooProp
&operator[foo]=@@
&value[foo]=fooValue
&value[]=value
&lang[0]=en
&property[5]=otherProp
```

will result with an internal representation of:

```
property: {          5: otherProp, foo: fooProp }
operator: {                        foo: @@      }
value:    {0: value,               foo: fooValue}
lang:     {0: en                                }
```

and the search condition _find all resources having at the same time: a triple with value `value@en` and any triple with the `otherProp` and a triple with property `fooProp` and value matching a full text search for `fooValue`_.

## Support in frameworks

In most cases you won't be creating the API request URL by hand. You'll use some HTTP client framework/library instead.

Some of them, support the serialization used by the ARCHE API out of the box, e.g.
let's try to perform a following search: 
_find all resources with `someProp` having either `somePropValue1` or `somePropValue2` value and `otherProp` having `otherPropValue`_:

```js
// jQuery example
jQuery.ajax({
  url: 'https://arche.acdh.oeaw.ac.at/api/search',
  data: {
    'property': ['someProp',                           'otherProp'],
    'value':    [['somePropValue1', 'somePropValue2'], 'otherPropValue'],
    'readMode': 'resource',
    'format': 'text/turtle'
  },
  success: function(d) {console.log(d)}
})
```
```php
// PHP
$query = http_build_query([
    'property' => ['someProp',                           'otherProp'],
    'value'    => [['somePropValue1', 'somePropValue2'], 'otherPropValue'],
    'readMode' => 'resource',
    'format'   => 'text/turtle'
]);
// just with file_get_contents
$response = file_get_contents('https://arche.acdh.oeaw.ac.at/api/search?' . $query);
echo $response;
// PSR-7 & PSR-18 way provided by Guzzle
$client = new GuzzleHttp\Client();
$request = new GuzzleHttp\Psr7\Request('GET', 'https://arche.acdh.oeaw.ac.at/api/search?' . $query);
$response = $client->sendRequest($request);
echo $response->getBody();
```

while for others some manual job is needed.

Most notably in Python I am not aware of any HTTP client library able to serialize to URL any more complex data structure.
Requests is only able to serialize lists (by just repeating the parameter name) which does the job until we can rely
on implicit enumeration but requires manual tuning if we can't:

```python
# Python with requests
import requests 
resp = requests.get(
  'https://arche.acdh.oeaw.ac.at/api/search',
  params={
    'property[]': ['someProp', 'otherProp'],
    'value[0][]': ['somePropValue1', 'somePropValue2'],
    'value[1]': 'otherPropValue',
    'readMode': 'resource',
    'format': 'text/turtle'
  }
)
print(resp.text)
```

# Ordering results

## Simple case

Just use the `oderbBy[]` request parameter coupled with the `orderByLang` if needed,
e.g. let's search for all resources bigger than 1.3 GB ordering results by their `acdh:hasTitle`
(in any language provided):

```
https://arche.acdh.oeaw.ac.at/api/search
  ?property[0]=https://vocabs.acdh.oeaw.ac.at/schema#hasRawBinarySize
  &operator[0]=>
  &value[0]=13000000000
  &orderBy[0]=https://vocabs.acdh.oeaw.ac.at/schema#hasTitle
  &readMode=resource
  &format=text/turtle
  
https://arche.acdh.oeaw.ac.at/api/search?property%5B0%5D=https%3A%2F%2Fvocabs.acdh.oeaw.ac.at%2Fschema%23hasRawBinarySize&operator%5B0%5D=%3E&value%5B0%5D=10000000000&orderBy%5B0%5D=https%3A%2F%2Fvocabs.acdh.oeaw.ac.at%2Fschema%23hasTitle&readMode=resource&format=text%2Fturtle
```

And take a look at the returned data skipping uninteresting properties:

```
<https://arche.acdh.oeaw.ac.at/api/> <search://count> "7"^^<http://www.w3.org/2001/XMLSchema#integer> .

<https://arche.acdh.oeaw.ac.at/api/23174>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize  "17222812879"^^<http://www.w3.org/2001/XMLSchema#long>;
    <search://order>       "7"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1> "KHM-ANSA-IV3456_raw3d.zip";
    acdh:hasTitle          "KHM-ANSA-IV3456_raw3d.zip"@en.
<https://arche.acdh.oeaw.ac.at/api/37779>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize  "13039382156"^^<http://www.w3.org/2001/XMLSchema#long>;
    <search://order>       "6"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1> "KHM-ANSA-IV431_raw3d.zip";
    acdh:hasTitle          "KHM-ANSA-IV431_raw3d.zip"@en.
<https://arche.acdh.oeaw.ac.at/api/46542>
    <search://match>       "true"^^<http://www.w3.org/2001/XMLSchema#boolean>;
    acdh:hasRawBinarySize   "15927776264"^^<http://www.w3.org/2001/XMLSchema#nonNegativeInteger>;
    <search://order>        "5"^^<http://www.w3.org/2001/XMLSchema#positiveInteger>;
    <search://orderValue1>  "sfm_raw_04-p1.zip";
    acdh:hasTitle           "sfm_raw_04-p1.zip"@de.
(...)
```

Discussion:

* The mapping of technical annotation properties to actual URIs follows the schema reported by the
  https://arche.acdh.oeaw.ac.at/api/describe, so that
  * `{repoCfg}$.schema.searchCount` is `<search://match>`,
  * `{repoCfg}$.schema.searchOrder` is `<search://order>`,
  * `{repoCfg}$.schema.searchOrderValue` + `{N}` is `<search://orderValue1>`, `<search://orderValue2>`, etc.
* All resources matched by the search are marked with `<search://match> true`.
  The one which isn't - `<https://arche.acdh.oeaw.ac.at/api/>` - is a technical resources
  used to indicate global search result properties like the number of resources matched by the search (here 7).
* The requested order can be read from `<search://order>` property values.
  The ascending order seems to be kept.
  * If you want an descending order, just prepend the property URI with a `^` in the `orderBy[]` parameter,
    e.g. `orderBy[0]=^https://vocabs.acdh.oeaw.ac.at/schema#hasTitle`.
  * If you want to order by more then one property, provide many `orderBy[]` request parameters,
    e.g. `orderBy[0]=firstOrderByThisProperty&orderBy[1]=thenOrderByThatProperty`.
    * Multiple `orderBy[]` parameter values are first sorted by their (implicit or explicit) key, e.g.
      `orderBy[foo]=someProp&orderBy[bar]=otherProp` will order results first by the `otherProp` values
      and only then by the `someProp` values (because the `bar` key is smaller than the `foo` key).
* Values actually used for ordering are provided in the `<search://orderValue1>` property.
  * As requested they are just equal to the `achd:hasTitle` property value of a given resource, just they
    lack the language tag.
    Here it's obvious but things can quickly get complicated if a resource has more than one title
    - see the next chapters.
  * There will be as many `<search://orderValueN>` properties in the output, as many `orderBy[]` parameters
    were provided in the request, e.g. if you requested `orderBy[0]=someProp&orderBy[1]=otherProp`,
    the output will contain both `<search://orderValue1>` (storing `someProp` values actually used for sorting)
    and ``<search://orderValue2>` (storing `otherProp` values actually used for sorting).
    * The N-th `<search://orderValueN>` property stores values of the n-th-order sorting property, so e.g.
      for `orderBy[foo]=someProp&orderBy[bar]=otherProp`, the `<search://orderValue1>` provides values of
      the `otherProp` and `<search://orderValue2>` provides values of the `someProp`.
      
## Collation

Different languages have different opinions on the characters order.
It's possible that the rule used by the ARCHE instance isn't in line with what you expect.
Fortunately there's can be easily checked and controlled:

* Inspect the `$.collation.default` value of the data returned by the `/describe` REST API endpoint
  to know what's the collation used by default by a given ARCHE instance.
  (e.g. https://arche.acdh.oeaw.ac.at/api/describe reports `en_US.UTF-8`).
* Use the `orderByCollation` request parameter to enforce ordering according to a given collation.
  * Inspect the `$.collation.available` to get the list of all collations available on a given
    ARCHE instance.

## Multiple values

A resource may have multiple values of a property used for results ordering.
A typical case are labels in multiple languages but you shouldn't optimistically assume it's the only possible case.
Consult metadata schema to check if a given property may multiple values and if they have a language tag.

In case of multiple property values ARCHE implements two rules:

* It the `orderByLang` request property is provided, all values with a non-matching values are excluded.
  * It a value has no language tag (technically speaking if its type is other than `rdfs:langString`),
    it's also included.
  * If there's no value left for a given resource, it's ordered as the last.
  * If a property has multiple values with the desired language tag, all of them are taken and the
    rule from the next point is applied.
  * It's a global setting. You can't assign different values for differnt `orderBy[]` parameter values.
* The lowest value among the available ones is used for the sorting.
  * This is a fully arbitrary ARCHE's design decision.
    We need to pick up a single value, we're using the lowest one.

E.g. let's assume we have following resources:

```
<res1> <hasTitle> "foo" ,
                  "bar"@en ;
       <hasAuthor> "Alice" .
<res2> <hasTitle> "bar"@en ,
                  "baz"@de ;
       <hasAuthor> "John" .
<res3> <otherProp> "placeholder" .
```

which all match the search. Now,

* For `orderBy[]=hasTitle&orderBy[]=^hasAuthor&orderByLang=en` the order will be `res2`, `res1`, `res3` because:
  * For `hasTitle` of `res1` we take the lowest among `foo` (qualifies because it has no lang tag) and `bar` (qualifies because its lang tag matches the `orderByLang`)
    giving us with `bar`.
  * For `res2` we skip `baz` and keep `bar` because both have lang tag but only the latter matches the `orderByLang`.
  * For `res3` we get nothing, so it ends up at the end of the sort.
  * As `res1` as `res2` have same sorting order according to the `hasTitle` we continue to the second order by property for them - `hasAuthor`.
    For `res1` it's `Alice` and for `res2` it's `John` but as a reverse order was requested (note the `^` in `orderBy[]=^hasAuthor`), sorting
    is done in reverse order and `res2` comes before `res1`
* For `orderBy[]=^hasTitle&orderByLang=de` the order will be `res1`, `res2`, `res3` because:
  * For `res1` the `foo` value of the `hasTitle` is taken (it doesn't have lang tag)
  * For `res2` the `baz` value of the `hasTitle` is taken (matches the `orderByLang`)
  * `res3` has no `hasTitle` so it goes to the end.
  * As the descending order was requested `foo` comes before `baz` and therefore `res1` before `res2`.
  

## Lack of value and non-literal values

If a given resource lacks a triple of the `orderBy[]` property **with a literal value**, then it's 
put at the end of the search results.

By the way it means **ARCHE doesn't allow to order by an object property values.**
This is because an ARCHE resource may have any number of (equally important) identifiers making
it impossible to tell, which one should be used (at least without introducing additional complexity
to the API).

# Paging 

Search results may be paged. This is controlled by the `offset` and `limit` parameters.

* You almost for sure want to combine paging with explicit ordering (see the previous chapter).
  * Still it's technically safe to use paging without providing `orderBy[]`.
    In such a case ARCHE resources are ordered by their internal identifiers
    which doesn't provide any intuitive order but is stable.
* You can always check the total number of resources matching the search by inspecting the
  `<restAPIbaseURL> <{repoCfg}$.schema.searchCount> "count" .` response triple, e.g.
  ```
  <https://arche.acdh.oeaw.ac.at/api/> <search://count> "7"^^<http://www.w3.org/2001/XMLSchema#integer> .
  ```
* The requested values of the `offset` and `limit` aren't included in the output.
  ARCHE hopes you can remember them :-)

Example - 


# Full text search

TODO

# SQL query-based search

TODO